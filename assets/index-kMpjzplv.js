import{_ as d,E as p}from"./el-card-BC1LQGcn.js";import"./base-BOVE5efH.js";import{E as c}from"./el-link-b02lqcaU.js";import{d as s,r as g,m as h,w as e,f as u,b as l,Q as i,o as m}from"./index-rcW_pH8g.js";import"./index-BRdTUeC1.js";import"./event-BB_Ol6Sd.js";import"./icon-D8zniuSg.js";import"./style-CQyj6J43.js";import"./use-global-config-ZfVEybhJ.js";import"./index-DL17Y2WH.js";import"./index-DNrEt1wy.js";const f=s({name:"jQueryPage "}),C=s({...f,setup(b){const r=g([{id:1,h2:"简介与下载"},{id:2,h2:"jQuery的使用步骤"},{id:3,h2:"jQuery和 DOM"},{id:4,h2:"jQuery API"},{id:5,h2:"jQuery设置样式"},{id:6,h2:"排他思想"},{id:7,h2:"链式编程"},{id:8,h2:"操作css方法"},{id:9,h2:"jQuery效果"},{id:10,h2:"事件切换"},{id:11,h2:"jQuery事件"},{id:12,h2:"动画队列及其停止排队方法"},{id:13,h2:"jQuery 属性操作"},{id:14,h2:"数据缓存 data()"},{id:15,h2:"全选按钮"},{id:16,h2:"jQuery文本属性值"},{id:17,h2:"jQuery元素操作"},{id:18,h2:"购物车模块，删减数量"},{id:19,h2:"购物车总计"},{id:10,h2:"创建 添加 删除"},{id:21,h2:"尺寸和位置操作"},{id:22,h2:"事情注册"},{id:23,h2:"解绑事件"},{id:24,h2:"事件对象"},{id:25,h2:"jQuery其他方法"},{id:26,h2:"多库共存"},{id:27,h2:"toDoList 分析"},{id:28,h2:"移动端的轮播图"}]);return(v,n)=>{const o=c,t=p,a=d;return m(),h(a,{data:r.value},{svg:e(()=>n[0]||(n[0]=[l("svg",{width:"48",height:"48",t:"1699148394151",class:"icon",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"5368"},[l("path",{d:"M121.3 283.3c-79.3 113.9-69.5 262-8.8 383 1.4 2.9 2.9 5.7 4.4 8.5 0.9 1.9 1.8 3.7 2.9 5.6 0.5 1 1.1 2.1 1.8 3.1l3 5.7 5.9 9.9c1.1 1.8 2.1 3.6 3.4 5.5 2 3.5 4.5 7 6.6 10.5 1 1.5 1.9 2.9 2.9 4.4 4.1 6.5 8 11.9 12 17.1l-0.4-0.6c2.9 4 5.8 7.9 9 11.8 1 1.4 2.1 2.8 3.2 4.3l8.3 10.1c1 1.1 2 2.5 3.1 3.7 3.7 4.4 7.5 8.7 11.4 13 0 0.1 0.1 0.1 0.2 0.3 4.8 6.1 10 11.5 15.7 16.3l0.2 0.1c3 3.1 6 6.1 9.2 9.1l3.8 3.6c4.1 3.9 8.3 7.8 12.7 11.5 0.1 0 0.1 0.1 0.2 0.1l2.1 1.9c3.8 3.3 7.6 6.6 11.6 9.7l4.7 3.9c3.2 2.5 6.5 5 9.7 7.5l5.1 3.9c3.5 2.6 7.2 5.2 10.7 7.7 1.3 0.9 2.6 1.9 3.9 2.7l1.1 0.9 10.5 6.9 4.5 3c5.5 3.5 11 6.8 16.4 10.1 1.6 0.8 3.1 1.7 4.6 2.5 4 2.3 8.2 4.7 12.3 6.8 2.2 1.3 4.6 2.4 6.9 3.5 2.8 1.6 5.7 3.1 8.7 4.7 0.7 0.2 1.5 0.5 2.2 0.9h-0.1c1.2 0.6 2.4 1.1 3.6 1.8 4.5 2.2 9.2 4.4 14 6.5 0.9 0.4 1.9 0.8 2.8 1.3 5.4 2.4 10.8 4.6 16.3 6.8 1.3 0.4 2.6 1 3.9 1.5 5 1.9 10.2 3.8 15.3 5.7l1.9 0.7c5.7 1.9 11.3 3.8 17.1 5.6 1.3 0.4 2.7 0.9 4.1 1.2 5.9 1.8 11.7 3.9 17.7 5.1 383.1 69.8 494.5-230.3 494.5-230.3C844.2 824 678.2 856.1 521 820.4c-5.8-1.3-11.7-3.2-17.5-4.9-8.3-2.4-16.6-5-24.7-7.8l3.5 1.1-2.3-0.9c-5.1-1.7-10-3.6-14.9-5.5-1.2-0.5-2.4-1-3.7-1.4l-0.4-0.1c-5.5-2.2-10.8-4.5-16.1-6.8-1.1-0.4-2.1-0.9-3.3-1.3-6.3-2.7-12.5-5.6-18.6-8.6l5.2 2.3c-1.4-0.6-2.6-1.2-3.9-1.9-3.5-1.7-7-3.5-10.4-5.3-2.6-1.2-5.2-2.6-7.7-4l0.8 0.4c-4.2-2.2-8.4-4.7-12.7-7-1.3-0.9-2.7-1.7-4.2-2.5-6.3-3.7-12.6-7.5-18.7-11.5l2.4 1.4c-1.6-1-3.1-2-4.6-3.1l0.2 0.2c-4.2-2.6-8.3-5.3-12.3-8.1l0.7 0.5c-1.3-0.9-2.5-1.8-3.8-2.7-4.8-3.3-8.3-5.9-11.9-8.6l0.9 0.6c-1.6-1.3-3.2-2.5-4.9-3.7-3.3-2.6-6.6-5-9.9-7.8l-4.4-3.5c-4.9-3.9-8.9-7.4-12.9-10.9l0.4 0.4c-0.4-0.4-0.9-0.8-1.3-1.1l-13-11.8-3.7-3.5c-3.1-3.1-6.2-6.1-9.3-9.2l-3.6-3.7c-3.9-3.8-7.6-7.8-11.3-11.8l-0.2-0.3-0.6-0.6c-4-4.4-7.8-8.8-11.7-13.2-1-1.1-1.9-2.4-3-3.6l-8.4-10.3c-3.8-4.8-7.5-9.7-11.2-14.6l-1.5-2.1c-87.2-119.1-118.7-283.3-49-418.1l-62.2 77.8z",fill:"#0769AD","p-id":"5369"}),l("path",{d:"M367.3 187.4c-57.5 82.5-54.2 192.8-9.5 280 8.3 16.4 16.7 30.2 26 43.3l-0.7-1.1c8.6 12.3 18.1 26.9 29.6 36.8 4.1 4.6 8.4 9.1 12.9 13.4l3.4 3.4c4.3 4.1 8.6 8.1 13.1 12.1l0.6 0.5c4.5 3.9 9.5 8.1 14.7 12.2l0.8 0.6c1.3 0.9 2.4 1.9 3.6 2.7 5.2 4 10.5 7.9 15.9 11.8l0.6 0.3c2.3 1.7 4.8 3.2 7.4 4.8 1 0.7 2.2 1.6 3.4 2.2 3.9 2.5 7.8 4.9 11.8 7.4l1.8 0.9c3.4 2 7 4 10.5 5.9 1.2 0.8 2.4 1.3 3.7 2 2.5 1.2 5 2.5 7.4 3.8l1.2 0.5c5 2.5 10.2 4.8 15.2 7.1 5.3 2.3 10.6 4.5 16 6.6 1.9 0.6 3.6 1.4 5.4 1.9 3.8 1.4 7.8 2.7 11.6 4l5.2 1.7c5.5 1.7 11 3.9 16.7 4.8 295.7 49 364.2-178.8 364.2-178.8-61.6 88.7-180.9 131-308.1 98-6.3-1.6-12.6-3.4-18.8-5.5l2.1 0.6c-1.8-0.5-3.4-1-5.1-1.6-3.9-1.3-7.9-2.7-11.7-4.1l-5.4-2c-4.2-1.7-8.4-3.2-12.5-5-1.3-0.6-2.4-0.9-3.4-1.5-5.2-2.4-10.5-4.7-15.6-7.2l-7.7-4-4.5-2.2c-3.4-1.8-6.6-3.7-9.9-5.6-0.8-0.4-1.6-0.8-2.4-1.3l0.1 0.1c-3.9-2.5-8.1-4.8-11.8-7.4-1.3-0.7-2.4-1.6-3.6-2.3l-7.8-5.1c-5.4-3.7-10.6-7.8-15.9-11.7-1.2-1.1-2.4-2-3.5-2.9-55.9-43.9-100-104-120.9-172.1-22-70.7-17.2-150 20.9-214.4l-47 66.4z",fill:"#0769AD","p-id":"5370"}),l("path",{d:"M574.1 115.7C540.2 165.4 537 227.2 560.3 282c24.8 58.3 75.5 104 134.6 125.7 2.4 0.9 4.8 1.7 7.3 2.6l3.3 1c3.4 1.1 6.9 2.4 10.4 3.1 163.4 31.5 207.6-83.9 219.5-100.8-38.9 55.9-104.2 69.3-184.2 49.8-7-1.7-13.8-3.8-20.5-6.4l1.2 0.4c-8.3-2.9-16.5-6.3-24.4-10.1l1.4 0.6c-14.4-7-28.2-15.4-40.9-25.1l0.6 0.4c-71.7-54.3-116.1-158-69.3-242.4l-25.2 34.9z",fill:"#0769AD","p-id":"5371"})],-1),l("h1",null,"jQuery",-1)])),describe:e(()=>n[1]||(n[1]=[l("p",null," jQuery是一个在现代Web开发中广泛应用的JavaScript库，它以其简洁的语法和丰富的功能极大地提高了开发效率.其设计宗旨是“Write Less, Do More”（写得更少，做得更多），即倡导开发者用更少的代码实现更多的功能。 ",-1)])),content:e(()=>[u(t,{id:"part1",shadow:"hover"},{default:e(()=>[n[8]||(n[8]=l("h2",null,"简介与下载",-1)),n[9]||(n[9]=l("p",null,"jQuery概述",-1)),n[10]||(n[10]=l("ul",null,[l("li",null,[i(" 仓库 "),l("ul",null,[l("li",null," 可以把很多东西放到这个仓库里面。找东西只需要到仓库里面查找到就可以了。 ")])]),l("li",null,[i(" JavaScript库： "),l("ul",null,[l("li",null," 即library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中， 封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。 ")])]),l("li",null,[i(" 简单理解： "),l("ul",null,[l("li",null," 就是一个JS文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好 的功能了。比如jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。 ")])]),l("li",null,[i(" 常见的JavaScript库 "),l("ul",null,[l("li",null,"jQuery"),l("li",null,"Prototype"),l("li",null,"YUI"),l("li",null,"Dojo"),l("li",null,"Ext JS"),l("li",null,"移动端的zepto")])])],-1)),n[11]||(n[11]=l("p",null,"jQuery的概念",-1)),n[12]||(n[12]=l("ul",null,[l("li",null," jQuery 是一个快速、简洁的JavaScript库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 j 就是JavaScript；Query查询；意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。jQuery封装了JavaScript常用的功能代码，优化了DOM操作、事件处理、动画设计和Ajax交互。学习jQuery本质：就是学习调用这些函数（方法）。jQuery出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。 "),l("li",null,[i(" 特点： "),l("ul",null,[l("li",null,"轻量级。核心文件才几十kb，不会影响页面加载速度"),l("li",null,"跨浏览器兼容。基本兼容现在主流的浏览器"),l("li",null,"链式编程、隐式迭代"),l("li",null,"对事件、样式、动画支持，大大简化了DOM操作"),l("li",null," 支持插件扩展开发。有着丰富的第三方的插件，例如： 树形菜单、日期控件、轮播图等 "),l("li",null,"免费、开源")])])],-1)),n[13]||(n[13]=l("p",null,"jQuery基本使用",-1)),l("ul",null,[l("li",null,[n[3]||(n[3]=i(" 下载官网： ")),u(o,{type:"primary",icon:"Link",target:"_blank",href:"https://jquery.com/"},{default:e(()=>n[2]||(n[2]=[i(" https://jquery.com/ ")])),_:1,__:[2]})]),l("li",null,[n[5]||(n[5]=i(" 各个版本的下载： ")),u(o,{type:"primary",icon:"Link",target:"_blank",href:"https://code.jquery.com/"},{default:e(()=>n[4]||(n[4]=[i(" https://code.jquery.com/ ")])),_:1,__:[4]})]),n[6]||(n[6]=l("li",null,[i(" 版本： "),l("ul",null,[l("li",null,"1x：兼容IE678等低版本浏览器，官网不再更新"),l("li",null,"2x：不兼容IE678等低版本浏览器，官网不再更新"),l("li",null,"3x：不兼容IE678等低版本浏览器，是官方主要更新维护的版本")])],-1)),n[7]||(n[7]=l("li",null,[i(" 下载最新版本 "),l("ul",null,[l("li",null," For help when upgrading jQuery, please see the upgrade guide most relevant to your version. We also recommend using the jQuery Migrate plugin. "),l("li",null," Download the compressed, production jQuery 3.6.0 压缩版本工作中使用压缩版本，复制出来新建jQuery.min.js 粘贴 ")])],-1))])]),_:1,__:[8,9,10,11,12,13]}),u(t,{id:"part2",shadow:"hover"},{default:e(()=>n[14]||(n[14]=[l("h2",null,"jQuery的使用步骤",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null," 引入jQuery文件（也要注意如果在代码上面使用，需要 load页面加载完再使用， 或者写在代码下面，再或者使用jQuery入口函数） "),l("li",null,[i(" jQuery入口函数，两种方式 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(function () {
      // ... 此处是页面DOM加载完成的入口      方法1 更简单，推荐使用
  })
  $(document).ready(function () {
      // ... 此处是页面DOM加载完成的入口      方法2
  }) `)])]),l("li",null," 等着DOM结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery帮我们完成了封装。 "),l("li",null,"相当于原生js中的DOMContentLoaded。等待主要的页面元素加载完成"),l("li",null," 不同于原生js中的load事件，是等页面文档、外部的js文件、CSS文件、图片加载完毕后，才执行内部代码。 "),l("li",null,"更推荐使用第一种方式。")],-1),l("p",null,"jQuery的顶级对象 $",-1),l("ul",null,[l("li",null,"自执行函数"),l("li",null," $ 是jQuery的别称，在代码中可以使用jQuery代替$，但一般为了方便，通常都直接使用$。 "),l("li",null," $ 是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用$包装成jQuery对象，就可以调用jQuery的方法。 ")],-1)])),_:1,__:[14]}),u(t,{id:"part3",shadow:"hover"},{default:e(()=>n[15]||(n[15]=[l("h2",null,"jQuery和 DOM",-1),l("p",null,"代码",-1),l("ul",null,[l("li",null,[i(" 用原生js获取来的对象就是DOM对象 "),l("pre",null,[l("code",{class:"language-js line-numbers"},"  var div = document.querySelector( 'div' );")])]),l("li",null,[i(" jQuery方法获取的元素就是jQuery对象 "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  var div = $("div");')])]),l("li",null,[i(" jQuery 对象只能使用jQuery方法，DoM对象则使用原生的Javascript 属性和方法 "),l("ul",null,[l("li",null,"DOM 对象： div. style .display = ' none '; // 影藏"),l("li",null,"jQuery对象： $ ( ' div' ) .hide () ; // 影藏")])]),l("li",null,[i(" js和jQuery获取的对象是不一样的，log输出 "),l("ul",null,[l("li",null," 原生js， console.dir ( 'div' ); //获取到的是DOM对象 ，里面有很多的属性和方法 "),l("li",null," jquery, console.dir ( $ ( 'div' ) ); //获取到的是jQuery对象，是一个伪数组存储形式 "),l("li",null," 注意：DOM对象只能是原生js使用，属性和方法，jQuery对象也只能使用jQuery方法，不能互通，需要转换 ")])]),l("li",null,[i(" jQuery 对象和 DOM 对象 "),l("ul",null,[l("li",null,"DOM对象与jQuery对象之间是可以相互转换的。"),l("li",null," 因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装.要想使用这些属性和方法需要把jQuery对象转换为DO对象才能使用。 "),l("li",null,[i(" DOM对象转换为jQuery对象：$（DOM对象），注意先获取DOM对象，然后再转换为jQuery对象，（）里不要加 ' ' 引号 ！ "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  var div = document.querySelector( 'div' ); // DOM获取完，执行转换
  $ ( div) ;                                 // 原生js已经获取元素了，所以不要加引号，不要加引号`)])]),l("li",null,[i(" jQuery对象转换为DOM对象（两种方式） "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  <video> src="url" muted></video>      // google浏览器需要加上muted禁音，muted才能自动播放
  // jQuery对象里面没有 video中，play();方法 ，但是原生有,原生js: video.play();，所以要转换为DOM对象
  $('video')[index] .play() ;           // index是索引号，如果视频只有一个就索引号为 [0] ，用[ ]
  $('video').get(index).play();         // index是索引号，如果视频只有一个就索引号为 （0）.用（）`)])]),l("li",null," jQuery转换为DOM对象，就是利用数组形式，加上索引号就可以实现转换，第二种方法是获取索引号，也可以转换 ")])])],-1)])),_:1,__:[15]}),u(t,{id:"part4",shadow:"hover"},{default:e(()=>n[16]||(n[16]=[l("h2",null,"jQuery API",-1),l("p",null,"jQuery选择器",-1),l("ul",null,[l("li",null," 原生JS获取元素方式很多，很杂，而且兼容性情况不一致，因此jQuery给我们做了封装，使获取元素统一标准。 "),l("li",null,[i(" $（“选择器”） // 里面选择器直接写CSS选择器即可，但是要加引号 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  // 里面选择器直接写CSS选择器即可，但是要加引号
  $('#id');                        /* ID选择器  获取指定ID的元素 */
  $("*")                           /* 全选选择器 匹配所有元素 */
  $(".class")                      /* 类选择器 获取同一类class的元素 */
  $("div")                         /* 标签选择器 获取同一类标签的所有元素 选取多个元素*/
  $("div,p,li")                    /* 并集选择器*/
  $("li.current")                  /* 交集选择器 交集元素 */
  $("ul>1i")                       /* 子代选择器 使用>号，获取亲儿子层级的元素；注意，并不会获取孙子层级的元素 */
  $("ul 1i")                       /* 后代选择器 使用空格，代表后代选择器，获取ul下的所有元素，包括孙子等 */`)])])],-1),l("p",null,"jQuery筛选选择器",-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $('#id');                        // ID选择器  获取指定ID的元素
  $('li:last')                     // 获取第一个li元素
  $('li:eq(2)')                    // 获取到的li元素中，选择索引号为2的元素，索引号index从0开始
  $('li:odd')                      // 获取到的li元素中，选择索引号为奇数的元素
  $('li:even')                     // 获取到的li元素中，选择索引号为偶数的元素
  $('li').parent();                // 查找父级
  $('ul').children("li");          // 相当于$("ul>li") 最近一级（亲儿子）
  $('ul').find("li");              // 相当于$("ul li") 后代选择器
  $('.first').siblings("li");      // 查找兄弟节点，不包括自己本身
  $('.first').nextAll();           // 查找当前元素之后所有的同辈元素
  $('.last').prevAll();            // 查找当前元素之前所有的同辈元素
  $('div').hasClass("protected");  // 检查当前的元素是否含有某个特定的类，如果有，则返回true
  $('li').eq(2);                   // 相当于$("li:eq(2)"),index 从 0 开始
  $('li').parents();               // 添加上祖先选择器名称，可以返回指定祖先元素

  // 重点记住：（记得要加引号）
  parent();                        // 返回的是最近一级的父亲，爷爷是找不到的
  children();                      // 返回的是亲儿子 ul>li ，孙子找不到
  find();                          // 查找子孙后代 ul li ，可以指定哪个元素
  siblings();                      // 查找兄弟元素，不包含自己
  eq();                            // 选择第几个元素，是方法，不是选择器，（）里面是索引号，从0开始，推荐使用`)],-1),l("p",null,"综合案例",-1),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <style>
    * { padding: 0;margin: 0;}
    .nav li {margin-right: 30px;float: left;width: 100px;height: 20px;border: 1px solid red;list-style: none;}
    .nav li ul {display: none;list-style: none;}
    .nav li ul li {border: 1px solid rgb(143, 58, 241);}
  </style>
  </head>

  <body>
  <ul class="nav">
      <li>
          <a href="#">导航1</a>
          <ul>
              <li>子菜单2</li><li>子菜单3</li><li>子菜单4</li> <li>子菜单5</li><li>子菜单6</li>
          </ul>
      </li>
      <li>...
      </li>
      <li>...
      </li>
  </ul>
  <script>
      $(function() { //入口函数
          // 1、选中nav下的亲儿子li,孙子li 不要选中.当hover的时候,不要加on
          $('.nav>li').mouseover(function() {
                  // 2、当鼠标经过当前的li时，他的孩子ul,show();显示出来
                  $(this).children('ul').show();
              })
              // 3、鼠标离开，其他影藏
          $('.nav>li').mouseout(function() {
              // 4、当鼠标离开当前的li时，hide();影藏显示
              $(this).children('ul').hide();
          })
      })
  <\/script>`)],-1)])),_:1,__:[16]}),u(t,{id:"part5",shadow:"hover"},{default:e(()=>n[17]||(n[17]=[l("h2",null,"jQuery设置样式",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null,"语法： $('元素'). css ('属性'，'属性值')； //记住要加引号"),l("li",null,"例如： $('#div') . css ( 'color' , ' red ' );"),l("li",null,[i(" 为什么css(); 里只写了一个属性和值，页面中的div，全部变化？ "),l("ul",null,[l("li",null," 因为：隐式迭代（重要）。遍历内部DOM元素（伪数组形式存储）的过程就叫做隐式迭代。 "),l("li",null," 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 "),l("li",null,[i(" 分析： "),l("ul",null,[l("li",null,"获取所有匹配的div"),l("li",null,"在内部隐秘的遍历循环操作"),l("li",null,"给每个元素都添加css 方法"),l("li",null," 注意，只有在需要在相同操作的时候才能用，不同的操作需要使用筛选选择器方法 :eq(); ")]),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(function () {
      $('div' ).css('background-color', 'pink');
  })`)])])])])],-1)])),_:1,__:[17]}),u(t,{id:"part6",shadow:"hover"},{default:e(()=>n[18]||(n[18]=[l("h2",null,"排他思想",-1),l("p",null,"代码",-1),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <!-- 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式 -->
  <button>按钮1</button><button>按钮2</button><button>按钮3</button>
  <button>按钮4</button><button>按钮5</button>

  <script>
      $(function() {  //入口函数
          // 1、获取元素，添加处理程序
          $('button').click(function() {
              // 2、点击了当前按钮变色
              $(this).css('color', 'blue');
              // 3、其他兄弟去掉变色
              $(this).siblings('button').css('color', '');
          })
      })
  <\/script>

  <!-- 案例：TAB栏切换
  1、核心原理：鼠标经过左侧盒子某个小li,就让内容区盒子相对应图片显示，其余的图片影藏
  2、需要得到当前i的索引号，就可以显示对应索引号的图片
  3、jQuery得到当前元素索引号$（this）.index（）
  4、中间对应的图片，可以通过eq（index）方法去选择
  5、显示元素show（），隐藏元素hide（） -->
  <style>
      * { padding: 0;margin: 0;box-sizing: border-box;}
      .box {width: 400px; height: 200px;border: 1px solid red;overflow: hidden;}
      #left {float: left;height: 197px;list-style: none;border: 1px solid skyblue;}
      #left li {width: 100%;height: 50px;line-height: 50px;border: 1px solid black;}
      #left li a {text-decoration: none;}
      #content {float: right;width: 350px; height: 197px;border: 1px solid blue;}
  </style>
  </head>
  <body>
  <div class="box">
      <ul id="left">
          <li><a href="">图片1</a></li><li><a href="">图片2</a></li>
          <li><a href="">图片3</a></li><li><a href="">图片4</a></li>
      </ul>
      <div id="content">
          <div><a href="#"><img src="./images/img1.png" alt=""></a></div>
          <div><a href="#"><img src="./images/img3.png" alt=""></a></div>
          <div><a href="#"><img src="./images/img2.png" alt=""></a></div>
          <div><a href="#"><img src="./images/img1.png" alt=""></a></div>
      </div>
  </div>
  <script>
    $(function() { //入口函数
        $('#left li').mouseover(function() {                                 // 1、添加鼠标经过事件，添加处理程序
             var index = $(this).index();                                    // 2、当鼠标经过当前li时，拿到li的索引号
             $('#content div').eq(index).show();                             // 3、并且把图片索引号.显示出来
             $('#content div').eq(index).siblings().hide();                  // 4、把图片索引号其他的兄弟但不包括自己，影藏

             $('#content div').eq(index).show().eq(index).siblings().hide(); // 合并写法：可以用链式编程写法
        })
    })
  <\/script>
  </body>`)],-1)])),_:1,__:[18]}),u(t,{id:"part7",shadow:"hover"},{default:e(()=>n[19]||(n[19]=[l("h2",null,"链式编程",-1),l("p",null,"代码",-1),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <!-- 使用链式编程一定注意是哪个对象执行样式  -->
  <button>快速</button><button>快速</button><button>快速</button>
  <button>快速</button><button>快速</button>
  <script>
      $(function() {
          $('button').click(function() {
              // 之前的写法
              $(this).css('background', 'pink');
              $(this).siblings().css('background', '');

              // 用链式编程写法
              $(this).css('background', 'pink').siblings().css('background', '');
          })
      })
  <\/script>`)],-1)])),_:1,__:[19]}),u(t,{id:"part8",shadow:"hover"},{default:e(()=>n[20]||(n[20]=[l("h2",null,"操作css方法",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null,[i(" jQuery样式操作： jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式 "),l("ul",null,[l("li",null,[i(" 参数只写属性名，则是返回属性值，是带有单位的字符串 "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  $(this).css("color");')])]),l("li",null,[i(" 参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号 "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  $(this).css("color" , "300");         // $(this).css("color" , 300);')])]),l("li",null,[i(" 参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号，不是数字需要加引号 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(this).css({
      "color": "white",                 // 属性可以加上引号，但是值非数字必须要加引号。
      fontSize: "20px",                 // 属性可以不加引号，但是值非数字必须要加引号。
      "backgroundColor": ' red'         // 当出现复合属性，需要采用驼峰命名法 。
  });`)])])])])],-1),l("p",null,"设置类样式方法",-1),l("ul",null,[l("li",null,[i(" 作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点。 "),l("ul",null,[l("li",null,[i(" 1. 添加类，注意类不要加点 "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  $("div").addClass("current");')])]),l("li",null,[i(" 2. 删除类 "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  $("div").removeClass("current");')])]),l("li",null,[i(" 3. 切换类 "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  $("div").toggleClass("current");   // 类似B站换一换，点击后，图片旋转，添加上旋转动画就可以实现了')])])])]),l("li",null,[i(" 案例 "),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <ul>
      <li>导航栏1</li><li>导航栏2</li><li>导航栏3</li><li>导航栏4</li><li>导航栏5</li>
  </ul>
  <script>
      $(function() { //入口函数
          $('ul li').click(function() {
          1、   $(this).addClass('current').siblings().removeClass('current');
          2、   $(this).toggleClass('current');
          })
      })
  <\/script>

  <script>        // 原生js tab切换栏
      // 获取元素
      var tab_list = document.querySelector(".tab_list");
      var lis = tab_list.querySelectorAll("li");
      var items = document.querySelectorAll(".item");
      // for 循环绑定点击事件
      for(var i = 0; i<list.length;i++){
        // 开始给5个li设置索引号
        lis[i].setAttribute("index",i);
        lis[i].onclick = function(){
          // 1.上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想）修改类名的方式
          // 干掉所有人 其余的li 清除 class这个类
          for(var  i = 0;i<lis.length;i++){
            lis[i].className = "";
          };
          // 留下我自己
          this.className = "current";
          // 2.下面的显示内容模块
          var index = this.getAttribute("index");
          console.log(index);
          // 干掉所有人让其余item 这些div影藏
          for(var i = 0; i<item.length;i++){
            items[i].style.display = "block";
          };
        };
      };
  <\/script>

  <script>      // jQuery tab栏切换
      // 1.点击上部的li,当前li 添加current类，其余兄弟移除类
      $(".tab_list li").click(function(){
          // 链式编程操作
          $(this).addClass("current").siblings().removeClass("current");
          // 2.点击的同事，得到当前的li索引号
          var index = $(this).index();
          console.log(index);
          // 3.让下部里面相应索引号的item显示，其余的item影藏
          $(".tab_con .item").eq(index).show().siblings().hide();
      })
  <\/script>`)])])],-1),l("p",null,"类操作与className区别",-1),l("ul",null,[l("li",null,"原生JS中className会覆盖元素原先里面的类名。"),l("li",null," jQuery里面类操作只是对指定类进行操作，不影响原先的类名。相当于追加 , addClass ")],-1)])),_:1,__:[20]}),u(t,{id:"part9",shadow:"hover"},{default:e(()=>n[21]||(n[21]=[l("h2",null,"jQuery效果",-1),l("p",null,"表格",-1),l("table",null,[l("tbody",null,[l("tr",null,[l("th",null,"显示隐藏"),l("th",null,"滑动"),l("th",null,"淡入淡出"),l("th",null,"自定义动画")]),l("tr",null,[l("td",null,"show()"),l("td",null,"slideDown()"),l("td",null,"fadeIn()"),l("td")]),l("tr",null,[l("td",null,"hide()"),l("td",null,"slideUp()"),l("td",null,"fadeOut()"),l("td",null,"animate()")]),l("tr",null,[l("td",null,"toggle()"),l("td",null,"slideToggle()"),l("td",null,"fadeToggle()"),l("td")]),l("tr",null,[l("td"),l("td"),l("td",null,"fadeTo()"),l("td")])])],-1),l("ul",null,[l("li",null,[i(" 上面的效果，代码都跟以下显示影藏一样的写法，代码规范和意思都一样 "),l("ul",null,[l("li",null,[i(" 注意1： 在淡入淡出中，fadeTo() 是改变透明度的，这个透明度是必须要写的，取值0~1 之间，速度也是要写 fadeTo([speed] , opacity, [easing] , [fn]) "),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <head>
      <style>
          * { padding: 0; margin: 0; }
          body {background-color: black; }
          .box {width: 710px;height: 400px;border: 1px solid red;}
          .box ul li {margin-right: 5px;float: left;}
      </style>
  </head>

  <body>
      <div class="box">
          <ul class="nav">
              <li><img src="./images/img1.png" alt=""></li>
              <li><img src="./images/img2.png" alt=""></li>
              <li><img src="./images/img3.png" alt=""></li>
              <li><img src="./images/img1.png" alt=""></li>
          </ul>
      </div>
  </body>

  <script>
      $(function() {
          $('.box ul li').hover(function() {
              $(this).siblings().stop().fadeTo(500, 0.5);
          }, function() {
              $(this).siblings().stop().fadeTo(500, 1);
          })
      })
  <\/script>`)])]),l("li",null,[i(" 注意2：animate 自定义动画参数为4个，语法: animate(params, [speed] , [easing] , [fn]) "),l("ul",null,[l("li",null," params：想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法borderLeft。其余参数都可以省略。 "),l("li",null,' speed：三种预定速度之一的字符串（“slow"，"normal"，“fast”）或表示动画时长的毫秒数值（如：1000）。 '),l("li",null,' easing:（Optional）用来指定切换效果，默认是“swing”，可用参数"linear”，匀速。 '),l("li",null," fn：回调函数，在动画完成时执行的函数，每个元素执行一次。 "),l("li",null,"添加动画，盒子必须要加定位")]),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $("button").click(function(){
    $("div").animate({
        left:500,
        top: 300,
        opacity: .4,
        width: 500
    })
  })`)])])])]),l("li",null,[i(" 显示影藏效果（一般不跟参数，直接显示影藏就行）, 语法规范: "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  show([speed],[easing],[fn])
  hide([speed],[easing],[fn])
  toggle([speed],[easing],[fn])   `)])]),l("li",null,[i(" 显示参数 "),l("ul",null,[l("li",null,"参数都可以省略，无动画直接显示。"),l("li",null,' speed：三种预定速度之一的字符串（“slow"，"normal"，“fast”）或表示动画时长的毫秒数值（如：1000）。 '),l("li",null,' easing:（Optional）用来指定切换效果，默认是“swing”，可用参数"linear”，匀速。 '),l("li",null,"fn：回调函数，在动画完成时执行的函数，每个元素执行一次。")])])],-1)])),_:1,__:[21]}),u(t,{id:"part10",shadow:"hover"},{default:e(()=>n[22]||(n[22]=[l("h2",null,"事件切换",-1),l("p",null,"hover( [over,]out );",-1),l("ul",null,[l("li",null,"over：鼠标移到元素上要触发的函数（相当于mouseenter）"),l("li",null,[i(" out：鼠标移出元素要触发的函数（相当于mouseleave） "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  <script>
      //第一个函数是鼠标经过的，第二个函数是鼠标离开的
      $("div").hover(function () {}, function () {});
  <\/script>

  <script>
      //事件切换hover如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数
      $("div").hover(function () {
        $(this).children("ul").slideToggle();
      })
  <\/script>`)])]),l("li",null,[i(" 微博下拉列表改进： "),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <!-- 微博下拉列表改进：-->
  <head>
      <style>
            * { padding: 0;margin: 0;}
            .nav li {margin-right: 30px;float: left;width: 100px;height: 20px;border: 1px solid red;list-style: none;
            }
            .nav li ul {display: none;list-style: none;}
            .nav li ul li {border: 1px solid rgb(143, 58, 241);}
      </style>
  </head>
  <body>
      <ul class="nav">
          <li>
              <a> href="#">导航1</a>
              <ul>
                  <li>子菜单1</li>
                  <li>子菜单2</li>
                  <li>子菜单3</li>
              </ul>
          </li>
          <li>...
          </li>
      </ul>
      <script>
          $(function() {
              $('.nav li').hover(function() {
                  $(this).children('ul').slideDown(200);
              }, function() {
                  $(this).children('ul').slideUp(200);
              })
          })
      <\/script>

      <!-- 再改进，只写一个函数的时候： -->
      <script>
          $(function() {
              $('.nav li').hover(function() {
                  $(this).children('ul').slideToggle(200);
              })
          })
      <\/script>
  </body>`)])])],-1)])),_:1,__:[22]}),u(t,{id:"part11",shadow:"hover"},{default:e(()=>n[23]||(n[23]=[l("h2",null,"jQuery事件",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null,[i(" click事件 "),l("ul",null,[l("li",null," 单击事件，类似于PC端的click，但在移动端中，连续click的触发有200ms ~ 300ms的延迟 ")])]),l("li",null,[i(" touch类触摸事件： "),l("ul",null,[l("li",null,"touchstart： 手指触摸到屏幕会触发"),l("li",null,"touchmove： 当手指在屏幕上移动时，会触发"),l("li",null,"touchend： 当手指离开屏幕时，会触发"),l("li",null," touchcancel： 可由系统进行的触发，比如手指触摸屏幕的时候，突然alert一下，或者系统中其他打断了touch的行为，可以触发 ")])]),l("li",null,[i(" tap类事件: 触碰事件，我目前还不知道它和touch的区别，一般用于代替click事件 "),l("ul",null,[l("li",null,"tap: 手指碰一下屏幕会触发"),l("li",null,"longTap: 手指长按屏幕会触发"),l("li",null,"singleTap: 手指碰一下屏幕会触发"),l("li",null,"doubleTap: 手指双击屏幕会触发")])]),l("li",null,[i(" swipe类事件: "),l("ul",null,[l("li",null,"swipe： 手指在屏幕上滑动时会触发"),l("li",null,"swipeLeft： 手指在屏幕上向左滑动时会触发"),l("li",null,"swipeRight： 手指在屏幕上向右滑动时会触发"),l("li",null,"swipeUp： 手指在屏幕上向上滑动时会触发"),l("li",null,"swipeDown： 手指在屏幕上向下滑动时会触发")])])],-1)])),_:1,__:[23]}),u(t,{id:"part12",shadow:"hover"},{default:e(()=>n[24]||(n[24]=[l("h2",null,"动画队列及其停止排队方法",-1),l("p",null,"代码",-1),l("ul",null,[l("li",null," 动画或者效果队列一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 "),l("li",null,"停止排队stop ( )")],-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $("div").hover(function () {
      $(this).children("ul").stop().slideToggle();            // stop 方法必须写到动画的前面，谁做动画就写在谁的前面
  })

  // 注意：stop()写到动画或者效果的前面，相当于停止结束上一次的动画。写到后面则出错，停止效果。
  $(function() {
      $('.nav li').hover(function() {
          $(this).children('ul').stop().slideToggle(200);     // stop()方法用于停止动画或效果。
      })
  })`)],-1),l("p",null,"案例：手风琴效果",-1),l("ul",null,[l("li",null,"布局：大盒子包含着 li ，宽224px 大图，宽69px 小图"),l("li",null," 每个图片有一个大图片和一个小图片 ，小图片采用定位形式，定到左边，因为是可以点击，所以用<a>包裹 "),l("li",null,"一开始小图片是看得见的，大图片是用display：none影藏起来"),l("li",null,"定义一个current 类，大图片显示，小图片影藏"),l("li",null,[i(" 鼠标经过某个 li 有两步操作 "),l("ul",null,[l("li",null,"当前i宽度变为224px，同时里面的小图片淡出，大图片淡入"),l("li",null,"其余兄弟li 宽度变为69px，小图片淡入，大图片淡出")])])],-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  <script> src="js/jquery.min.js"><\/script>
  <script type="text/javascript">
      $(function() {
          // 鼠标经过某个小li 有两步操作：
          $(".king li").mouseenter(function() {
              // 1.当前小li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入
              $(this).stop().animate({
                  width: 224
              }).find(".small").stop().fadeOut().siblings(".big").stop().fadeIn();
              // 2.其余兄弟小li宽度变为69px， 小图片淡入， 大图片淡出
              $(this).siblings("li").stop().animate({
                  width: 69
              }).find(".small").stop().fadeIn().siblings(".big").stop().fadeOut();
          })
      });
  <\/script>`)],-1)])),_:1,__:[24]}),u(t,{id:"part13",shadow:"hover"},{default:e(()=>n[25]||(n[25]=[l("h2",null,"jQuery 属性操作",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null," 设置或获取元素固有属性值 prop（） ，但是注意获取不了自定义属性，获取自定义属性 index 需要用 attr（） "),l("li",null," 所调元素固有属性就是元素本身自带的属性，比如<a>元素里面的href，比如<input>元素里面的type。 "),l("li",null,[i(" 获取属性语法: "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  element.prop ( "属性名" );')])]),l("li",null,[i(" 设置属性语法: "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  element.prop ( "属性名"," 属性值 ");')])]),l("li",null,[i(" 获取自定义属性语法: "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  element.attr( "属性名" );')])]),l("li",null,[i(" 修改自定义属性语法: "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  element.attr( "属性名" ,"属性" );')])]),l("li",null,"修改获取自定义属性类似于原生JS 的 get/setAttribute( )")],-1)])),_:1,__:[25]}),u(t,{id:"part14",shadow:"hover"},{default:e(()=>n[26]||(n[26]=[l("h2",null,"数据缓存 data( )",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null," data () 方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都将被移除。 "),l("li",null,[i(" 附加数据语法： "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  data( "属性名" , "属性" );')])]),l("li",null,[i(" 获取数据语法： "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  data( "属性名");')])]),l("li",null,[i(" 获取自定义属性： "),l("ul",null,[l("li",null," 这个方法获取data-index h5自定义属性，第一个不用写data- ，而且返回的是数字型，而attr()返回的是字符型，需要加上data- ")])])],-1)])),_:1,__:[26]}),u(t,{id:"part15",shadow:"hover"},{default:e(()=>n[27]||(n[27]=[l("h2",null,"全选按钮",-1),l("p",null,"思路",-1),l("ul",null,[l("li",null," 全选思路：里面3个小的复选框按钮（j-checkbox）选中状态（checked）跟着全选按钮（checkAll）走。 "),l("li",null," 因为checked是复选框的固有属性，此时我们需要利用prop（）方法获取和设置该属性。 "),l("li",null,"把全选按钮状态赋值给3小复选框就可以了。"),l("li",null,"当我们每次点击小的复选框按钮，就来判断："),l("li",null," 如果小复选框被选中的个数等于3就应该把全选按钮选上，否则全选按钮不选。 "),l("li",null,":checked选择器：checked查找被选中的表单元素。")],-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(".checkAll").change(function () {
      $(".j-checkbox .checkAll").prop("checked", $(this).prop("checked"));
  });
  $(".j-checkbox").change(function () {
      if ($(".j-checkbox:checked").length === 3) {
          $(".checkAll").prop("checked", true);
      } else {
          $(".checkAll").prop("checked", false);
      }
  })

  // $('.j-checkbox, .checkAll') 是并集选择器，包含了.checkAll，同样做出变化
  // $(".j-checkbox:checked").length 是所有小的复选框个数， ：checked 可获取到勾选复选框的DOM对象，
  // 里面有长度属性
  // 判断条件中，  === 3 ，3可以设置成变量，就是小复选框的个数，$( '.j-checkbox' ) .length`)],-1)])),_:1,__:[27]}),u(t,{id:"part16",shadow:"hover"},{default:e(()=>n[28]||(n[28]=[l("h2",null,"jQuery文本属性值",-1),l("p",null,"代码",-1),l("ul",null,[l("li",null,[i(" 普通元素内容 html () //相当于原生innerHTML "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  html ()              // 获取元素的内容
  html ("内容")         // 设置元素的内容`)])]),l("li",null,[i(" 普通元素文本内容 text () //相当于原生innerText "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  text ()              // 获取元素文本的内容
  text("内容")          // 设置元素文本的内容`)])]),l("li",null,[i(" 普通设置表单值 val () //相当于原生innerText "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  val()                // 获取元素文本的内容
  val("内容")           // 设置元素文本的内容`)])])],-1)])),_:1,__:[28]}),u(t,{id:"part17",shadow:"hover"},{default:e(()=>n[29]||(n[29]=[l("h2",null,"jQuery元素操作",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null,"主要是遍历、创建、添加、删除元素操作。"),l("li",null,[i(" 遍历元素 "),l("ul",null,[l("li",null," jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同操作，就需要用到遍历。 "),l("li",null,[i(" 遍历方法1 语法 "),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <script>>
      $("div").each(function (index, domEle) {xxx;}); // index是可以自定义的，比如 i
  <\/script>

  <body>
      <!--
          1.each0方法遍历匹配的每一个元素。主要用DOM处理。each每一个
          2.里面的回调函数有2个参数：index是每个元素的索引号；demEle是每个DOM元素对象，不是jquery对象
          3.所以要想使用jquery方法，需要给这个dom元素转换为jquery对象$（domE1e）
      -->
      <div>盒子1</div>
      <div>盒子2</div>
      <div>盒子3</div>
  </body>
  <script>>
      $(function () {
          var num = 0;                                     // 存储想加的变量
          var arr = ["red", "blue", "pink"];               // 存储属性值的数组
          $("div").each(function (index, domEle) {
              $(domEle).css("color", arr[index]);          // index 和 domEle 是可以自定义的
              num += parseInt($(domEle).text().substr(2)); // parseInt取整，substr（2）截取几个字符
          });
          console.log(num);
      });
  <\/script>`)])]),l("li",null,[i(" 遍历方法2 语法 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $.each(object,function(index,element){xxx;})

// 1.$.each（）方法可用于遍历任何对象。主要用于数据处理，比如数组，对象
// 2.里面的函数有2个参数：index是每个元素的索引号；element 遍历内容，如果是对象，index相当于属性名，ele是属性值
$.each($('div'),function(i,domEle){ // 遍历元素
    console.log(i);
})
$.each(arr,function(i,domEle){      // 遍历数组
    console.log(i,domEle);
})
$.each({                            // 遍历对象
    name: 'uname', age: 18
},function(i,domEle){
    console.log(i);
    console.log(domEle);
})`)])])])])],-1)])),_:1,__:[29]}),u(t,{id:"part18",shadow:"hover"},{default:e(()=>n[30]||(n[30]=[l("h2",null,"购物车模块，删减数量",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null," 核心思路：首先声明一个变量，当我们点击+号（increment），就让这个值++，然后赋值给文本框。 "),l("li",null," 注意1：只能增加本商品的数量，就是当前+号的兄弟文本框（itxt）的值。修改表单的值是val()方法 "),l("li",null," 注意2：这个变量初始值应该是这个文本框的值，在这个值的基础上++。要获取表单的值, 减号（decrement）思路同理，但是如果文本框的值是1，就不能再减了。 ")],-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(".increment").click(function () {
      var n = $(this).siblings(".text").val();
      n++;
      $(this).siblings(".itxt").val(n);
  });
  $(".decrement").click(function () {
      var n = $(this).siblings(".text").val();
      if (n == 1) {
        return false
      };
      n--;
      $(this).siblings(".itxt").val(n);
  });`)],-1),l("p",null,"购物车修改商品小计分析",-1),l("ul",null,[l("li",null," 核心思路：每次点击+号或者一号，根据文本框的值乘以当前商品的价格就是商品的小计 "),l("li",null,"注意1：只能增加本商品的小计，就是当前商品的小计模块（p-sum）"),l("li",null,"修改普通元素的内容是text()方法"),l("li",null," 注意2：当前商品的价格，要把￥符号去掉再相乘截取字符串substr（1） "),l("li",null,"parents（‘选择器”）可以返回指定祖先元素"),l("li",null," 最后计算的结果如果想要保留2位小数通过 .toFixed（2）方法，数字可写想保留几位的数字 "),l("li",null," 用户也可以直接修改表单里面的值，同样要计算小计。用表单change事件 "),l("li",null,"用最新的表单内的值乘以单价即可但是还是当前商品小计")],-1)])),_:1,__:[30]}),u(t,{id:"part19",shadow:"hover"},{default:e(()=>n[31]||(n[31]=[l("h2",null,"购物车总计",-1),l("p",null,"代码",-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  function getSum() {
      var count = 0;                      // 计算总件数
      var money = 0;                      // 计算总价钱
      $(".itxt").each(function (i, ele) {
        count += parseInt($(ele).val());
      });
      $(".amount-sum em").text(count);
      $(".p-sum").each(function (i, ele) {
        money += parseFloat($(ele).text().substr(1));
      });
      $(".price-sum em").text("￥" + money.toFixed(2));
  };`)],-1)])),_:1,__:[31]}),u(t,{id:"part20",shadow:"hover"},{default:e(()=>n[32]||(n[32]=[l("h2",null,"创建 添加 删除",-1),l("p",null,"代码",-1),l("ul",null,[l("li",null,[i(" 创建元素 "),l("pre",null,[l("code",{class:"language-js line-numbers"},'  $("");           //动态创建')])]),l("li",null,[i(" 添加元素 - 内部 "),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <script>
      element.append("内容");    // 把内容放入匹配元素内部最后面，类似原生appendChild.
      element.prepend("内容");   // 把内容放入匹配元素内部最前面
  <\/script>

  <!-- 使用html 创建元素 会覆盖原来内容 -->
  <body>
    <button id="btn">1</button>
    <table></table>
    <script>
        let data = [{a: 1, b: 2, c: 3}, {a1: 2, b1: 3, c1: 4}];
        $(() => {
            $('#btn').click(function () {
                var list = [];
                for (let i = 0; i < data.length; i++) {
                    list.push("<tr>");               // 生成tr
                    for (var key in data[i]) {
                        list.push("<td>");           // 生成td
                        list.push(data[i][key]);
                        list.push("</td>");
                    };
                    list.push("</tr>");
                };
                $("table").html(list.join(""));
            });
        });
    <\/script>
  </body>

  <!-- 使用$（） 创建元素 会追加，不会覆盖 -->
  <body>
    <button id="btn">1</button>
    <table></table>
    <script>
        let data = [{a: 1, b: 2, c: 3}, {a: 2, b: 3,c: 4}];
        $(() => {
            $('#btn').click(function () {
                for (let i = 0; i < data.length; i++) {
                    let $tr = $(\`<tr>
                        /* 对象的属性名记得用引号，要不然会报错 a is mot defined */
                        <td>\${data[i]["a"]}</td>
                        <td>\${data[i]["b"]}</td>
                        <td>\${data[i]["c"]}</td>
                    </tr>\`);
                    $("table").append($tr);
                }
            });
        });
    <\/script>
  </body>`)])]),l("li",null,[i(" 添加元素-外部 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  element.after("内容")        // 把内容放入目标元素内部最后面
  element.before("内容")       // 把内容放入目标元素内部最前面

  // 1. 内部添加元素，生成之后，它们是父子关系。
  // 2. 外部添加元素，生成之后，他们是兄弟关系。`)])]),l("li",null,[i(" 删除元素 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  element.remove("内容")       // 删除匹配的元素 （本身） ul 删自己
  element.empty()              // 删除匹配的元素集合中所有的子节点 ，ul > li 删儿子
  element.html("")             // 清空匹配的元素内容 ul > li 删儿子，跟 empty 的作用是一样的`)])]),l("li",null,[i(" 商品删除模块： "),l("ul",null,[l("li",null,"核心思路：把商品remove0删除元素即可"),l("li",null," 有三个地方需要删除：1.商品后面的删除按钮2.删除选中的商品3.清理购物车 "),l("li",null," 商品后面的删除按钮：一定是删除当前的商品，所以从$（this）出发 "),l("li",null," 删除选中的商品：先判断小的复选框按钮是否选中状态，如果是选中，则删除对应的商品 "),l("li",null,"每次删除都要调用计总函数 getSum();")])]),l("li",null,[i(" 购物车选中商品添加背景 "),l("ul",null,[l("li",null,"核心思路：选中的商品添加背景，不选中移除背景即可"),l("li",null," 全选按钮点击：如果全选是选中的，则所有的商品添加背景，否则移除背景 "),l("li",null," 小的复选框点击：如果是选中状态，则当前商品添加背景，否则移除背景 "),l("li",null,"这个背景，可以通过类名修改，添加类和删除类")])])],-1)])),_:1,__:[32]}),u(t,{id:"part21",shadow:"hover"},{default:e(()=>n[33]||(n[33]=[l("h2",null,"尺寸和位置操作",-1),l("p",null,"代码",-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  width() / height()                              // 取得匹配元素宽度和高度值只算 width/height
  innerWidth() / innerHight()                     // 取得匹配元素宽度和高度值包含padding
  outerWidth() / outerHeight()                    // 取得匹配元素宽度和高度值包含padding、border
  outerWidth(true) / outerHeight(true)            // 取得匹配元素宽度和高度值包含padding、border、margin

  // 以上参数为空，则是获取相应值，返回的是数字型。
  // 如果参数为数字，则是修改相应值。参数可以不必写单位。
  // 位置主要有三个：offset()、position()、scrollTop() / scrollLeft() `)],-1),l("ul",null,[l("li",null,[i(" offset()设置或获取元素偏移 //取决于文档 "),l("ul",null,[l("li",null," offset0方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系。 "),l("li",null," 该方法有2个属性left、top。offset().top用于获取距离文档顶部的距离，offset().left用于获取距离文档左侧的距离。 "),l("li",null," 可以设置（修改）元素的偏移：offset（{top：10，left：30}）； 只对文档，不对父盒子 ")])]),l("li",null,[i(" position()获取元素偏移 //取决于父亲，并且只对可见元素有效 "),l("ul",null,[l("li",null," position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。 "),l("li",null,"position()方法只能获取 不能设置偏移")])]),l("li",null,[i(" scrollTop()/scrollLeft()设置或获取元素被卷去的头部和左侧 "),l("ul",null,[l("li",null,"scrollTop()方法设置或返回被选元素被卷去的头部。")]),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(function() {
      $(window).scroll(function() { //页面滚动事件
          console.log($(document).scrollTop());
      })
  })`)])]),l("li",null,[i(" 带有动画的返回顶部： "),l("ul",null,[l("li",null,"核心原理：使用animate动画返回顶部。"),l("li",null,"animate动画函数里面有个scrollTop属性，可以设置位置"),l("li",null,' 但是是元素做动画，因此$（"body，html"）.stop().animate( { scrollTop : 0 }); '),l("li",null," $( document) .stop().animate({scrollTop: 0}) 这样写是错误的，因为是元素做动画，不是文档 ")])]),l("li",null,[i(" 电梯导航： "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  var toolTop = $(".recommend").offset().top;
  $(window).scroll(function(){
      if($(document).scrollTop() >= toolTop){
          $(".fixedTool").fadeIn();
      } else{
          $(".fixedTool").fadeOut();
      }
  })

  // 点击电梯导航页面可以滚动到相应内容区域
  $(".fixedTool li").click(function(){
      var current = $(".floor .w").eq($(this).index()).offset().top;
      $("body,html").stop().animate({
          scrollTop: current
      })
  })

  // scrollTop: 0 就可以返回顶部`)])]),l("li",null,[i(" 需要改进： "),l("ul",null,[l("li",null," 当页面刷新时不会触发这个时间，所以需要把滚动封装成函数，当页面刷新时调用一次，滚动时也会调用。 "),l("li",null,"当选中的li，需要添加current 类名，其他兄弟移除 类名"),l("li",null," 当我们页面滚动到内容区域某个模块，左侧电梯导航，相对应的i模块，也会添加current类，兄弟移除current类。 "),l("li",null," 触发的事件是页面滚动，因此这个功能要写到页面滚动事件里面。 "),l("li",null," 需要用到each，遍历内容区域大模块。each里面能拿到内容区域每一个模块元素和索引号 "),l("li",null," 当我们点击了小1i此时不需要执行页面滚动事件里面的1i的背景选择添加currentl。需要添加节流阀，也叫互斥锁 ")])])],-1)])),_:1,__:[33]}),u(t,{id:"part22",shadow:"hover"},{default:e(()=>n[34]||(n[34]=[l("h2",null,"事情注册",-1),l("p",null,"代码",-1),l("ul",null,[l("li",null,[i(" 单个事件注册： "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  element.事件(function(){})

  // 例如：$（"div"）.click（function（）{事件处理程序}） ,其他事件和原生基本一致。
  // 比如mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll等`)])]),l("li",null,[i(" 事件处理on： "),l("ul",null,[l("li",null,"on() 方法在匹配元素上绑定一个或多个事件的事件处理函数"),l("li",null,[i(" element.on(events,[selector],fn) "),l("ul",null,[l("li",null,' events：一个或多个用空格分隔的事件类型，如“click“或“keydown"。是以对象形式写的 '),l("li",null,"selector：元素的子元素选择器。"),l("li",null,"fn：回调函数即绑定在元素身上的侦听函数。")])])]),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(function(){
      $("div").on({
          mouseenter: function(){
              $(this).css("background","skyblue");
          },
          click:function(){
              $(this).css("background","purple");
          }
      });
  });`)])]),l("li",null,[i(" 相同处理程序： 如果相同处理程序可以以下做法 （用空格隔开） "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $("div").on("mouseenter mouseleave",function(){
      $(this).toggleClass("current");
  })`)])]),l("li",null,[i(" on() 方法优势2： "),l("ul",null,[l("li",null," 可以事件委派操作。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。 ")]),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(function () {
      $(' ul').on(' click', '1i', function () {
          alert(' hello world!');
      });
  })

  // click是绑定在ul身上的，但是触发的对象是u1里面的小1i
  // 在此之前有bind()，live() delegate()等方法来处理事件绑定或者事件委派，最新版本的请用on替代他们。
  // 可以动态创建元素绑定事件，原先方法因为会出现：元素是后添加，导致无法绑定事件，但on则可以解决这个问题，因为是动态`)])]),l("li",null,[i(" 事件处理one ()： "),l("ul",null,[l("li",null," 写法跟 on()是一样的，作用也是一样的，都是可以绑定事件处理程序 "),l("li",null," one() 和 on ()的区别，one()事件只会触发一次，不需要解绑，但是 on() 需要，也需要解绑事件 "),l("li",null,"相当于一次性")])]),l("li",null,[i(" 自动触发事件trigger()： "),l("ul",null,[l("li",null," 有些事件希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件 不用鼠标点击触发。相当于定时器的效果 "),l("li",null,[i(" 语法 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  element.click();                        // 第一种写法，会触发元素的默认行为
  element.trigger( 'type' );              // 第二种写法，会触发元素的默认行为
  element.triggerHandler(  type  );       // 第三种写法，不会触发元素的默认行为 ，比如表单的光标 focus ,不会闪
`)])])])])],-1)])),_:1,__:[34]}),u(t,{id:"part23",shadow:"hover"},{default:e(()=>n[35]||(n[35]=[l("h2",null,"解绑事件",-1),l("p",null,"代码",-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  // off（）方法可以移除通过on（）方法添加的事件处理程序。
  // 1、如果（）里面参数为空，比如 $( ' div' ) .off( ) ; 就会 解绑所有 的绑定事件
  // 2、如果（）里面有参数，比如 $( ' div' ) .off( ' click' ) ; 表示 解绑了点击 事件
  // 3、可以跟两个参数，比如ul绑定了事件委托，ul下的li 触发，解除方法如下：
  $(function() {
      $('ul').on('click','li',function(){});
      //解除事件写法
      $('ul').off('click','li');
  })`)],-1)])),_:1,__:[35]}),u(t,{id:"part24",shadow:"hover"},{default:e(()=>n[36]||(n[36]=[l("h2",null,"事件对象",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null,[i(" 事件被触发，就会有事件对象的产生。 "),l("ul",null,[l("li",null,"element.on(events,[selector],function(event){})"),i(" = "),l("li",null,"阻止默认行为：event.preventDefault（）或者return false"),l("li",null,"阻止冒泡：event.stopPropagation（）")])]),l("li",null," 长按press事件会导致浏览器弹出菜单，苹果的可以用-webkit-touch-callout: none;来禁止，但是安卓的不行。 "),l("li",null,[i(" 禁止弹出只能用js来控制: "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  // 移动端禁止长按触发菜单
  window.addEventListener('contextmenu', function (e) {
      e.preventDefault();
  });`)])])],-1)])),_:1,__:[36]}),u(t,{id:"part25",shadow:"hover"},{default:e(()=>n[37]||(n[37]=[l("h2",null,"jQuery其他方法",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null," 如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用S.extend（）方法 "),l("li",null,[i(" 语法： "),l("pre",null,[l("code",{class:"language-js line-numbers"},"  $.extend([deep],target,object1,[objectN])")]),l("ul",null,[l("li",null,"deep：如果设为true为深拷贝，默认为false 浅拷贝"),l("li",null,"target：要拷贝的目标对象"),l("li",null,"object1：待拷到到第一个对象的对象。"),l("li",null,"objectN：待拷贝到第N个对象的对象。"),l("li",null," 浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象。 ")])]),l("li",null,[i(" 过程 "),l("ul",null,[l("li",null," 浅拷贝会把复杂类型的地址给拷贝过去，而不是值，targetObj自己用地址来调用这个复杂类型数据 "),l("li",null,"当targetObj修改了 msg的属性值，也会影响obj里的属性值"),l("li",null," 当targetObj里也有 msg 复杂数据类型，浅拷贝的话，会和obj的msg的数据类型冲突，从而会直接覆盖掉 ")])]),l("li",null,[i(" 深拷贝 "),l("ul",null,[l("li",null," 深拷贝，前面需要加true，完全克隆（拷贝的对象而不是地址），修改目标对象不会影响被拷贝对象。 "),l("li",null," 深拷贝过程，会完全拷贝，而且复杂数据类型会重新开辟一个空间，而不是像浅拷贝一样指向同一个地址 "),l("li",null," 因为不是指向同一个地址，所以当修改复杂数据类型的值时，不会影响，而且数据会合并，而不是覆盖 ")])])],-1)])),_:1,__:[37]}),u(t,{id:"part26",shadow:"hover"},{default:e(()=>[n[53]||(n[53]=l("h2",null,"多库共存",-1)),n[54]||(n[54]=l("p",null,"共存1",-1)),n[55]||(n[55]=l("ul",null,[l("li",null,[i(" 问题概述：jQuery使用作为标示符，随着jQuery的流行其他js库也会用这$作为标识符，这样一起使用会引起冲突。 "),l("ul",null,[l("li",null,[i(" $符号作为标识符，怎么用原生js实现的： "),l("ul",null,[l("li",null," 原因很简单，把 $作为了函数名，封装了一个函数，并传递参数，且有返回值； "),l("li",null," 这样 $('div') 相当于调用函数，并且传入实参，但是注意，这样写是调用不了jQuery的方法的，会报错 ")])])]),l("pre",null,[l("code",{class:"language-js line-numbers"},`  function $(ele){
      return document.querySelector(ele);
  }
  $('div');`)])]),l("li",null,[i(" 可观需求： "),l("ul",null,[l("li",null," 需要一个解决方案，让jQuery和其他的s库不存在冲突，可以同时存在，这就叫做多库共存。 ")])]),l("li",null,[i(" jQuery解决方案： "),l("ul",null,[l("li",null," 如果是$符号冲突，把里面的$符号统一改为jQuery。比如jQuery（“div'） "),l("li",null," jQuery变量规定新的名称：$.noConflict () var xx= $.noConflict0； ,意思是不冲突，自己定义名称 "),l("li",null,[i(" 例如： "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  var zidingyimingcheng  = jQuery. noConflict ();
  ziDingYiMingCheng . each( ) ;                    // 这样 zidingyimingcheng  就等价于 $  ,可以调用jQuery方法`)])])])])],-1)),n[56]||(n[56]=l("p",null,"共存2",-1)),l("ul",null,[n[48]||(n[48]=l("li",null," jQuery功能比较有限，想要更复杂的特效效果，可以借助于jQuery插件完成。 ",-1)),l("li",null,[n[42]||(n[42]=i(" 注意：这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件，因此也称为jQuery插件。 ")),l("ul",null,[l("li",null,[n[39]||(n[39]=i(" jQuery插件库 ")),u(o,{type:"primary",icon:"Link",target:"_blank",href:"http://www.jq22.com/"},{default:e(()=>n[38]||(n[38]=[i(" http://www.jq22.com/ ")])),_:1,__:[38]})]),l("li",null,[n[41]||(n[41]=i(" jQuery之家(推荐) ")),u(o,{type:"primary",icon:"Link",target:"_blank",href:"http://www.htmleaf.com/"},{default:e(()=>n[40]||(n[40]=[i(" http://www.htmleaf.com/ ")])),_:1,__:[40]})])])]),n[49]||(n[49]=l("li",null,[i(" 操作步骤： "),l("ul",null,[l("li",null,"选好样式，点击下载插件"),l("li",null,"引入相关文件。（jQuery文件和插件文件）"),l("li",null,"复制相关html、css、js（调用插件）。"),l("li",null,"如果不会就看网页中使用说明，这样更快捷")])],-1)),n[50]||(n[50]=l("li",null,"瀑布流",-1)),n[51]||(n[51]=l("li",null," 图片懒加载（图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载） ",-1)),n[52]||(n[52]=l("li",null,[i(" 当我们页面滑动到可视区域，再显示图片 "),l("ul",null,[l("li",null,"插件 库下载插件 http://www.jq22.com/，搜索懒加载"),l("li",null," 把dist 复制项目js 文件下，然后html页面引入EasyLazyload.min.js 和 jQuery.min.js "),l("li",null,"修改img 的src"),l("li",null,"ctrl +h 输入 <img src= 替换成 <img data-lazy-src="),l("li",null," 我们使用iquery插件库EasyLazyLoad。注意，此时的js引入文件和js调用必须写到DOM元素（图片）的最后面，先有图片 尾部复制调用 ")]),l("pre",null,[l("code",{class:"language-js line-numbers"},`  lazyLoadInit({
      coverColor: "white",
      coverDiv: "<h1>test</h1>",
      offsetBottom: 0,
      offsetTop: 0,
      showTime: 1100,
      onLoadBackEnd: function (i, e) {
          console.log("onLoadBackEnd:" + i);
      },
      onLoadBackStart: function (i, e) {
          console.log("onLoadBackStart:" + i);
      }
  });`)])],-1)),l("li",null,[n[47]||(n[47]=i(" 全屏滚动（fullpagejs） ")),l("ul",null,[l("li",null,[n[44]||(n[44]=i(" gitHub: ")),u(o,{type:"primary",icon:"Link",target:"_blank",href:"https://github.com/alvarotrigo/fullPage.js"},{default:e(()=>n[43]||(n[43]=[i(" https://github.com/alvarotrigo/fullPage.js ")])),_:1,__:[43]})]),l("li",null,[n[46]||(n[46]=i(" 中文翻译网站： ")),u(o,{type:"primary",icon:"Link",target:"_blank",href:"http://www.dowebok.com/demo/2014/77/"},{default:e(()=>n[45]||(n[45]=[i(" http://www.dowebok.com/demo/2014/77/ ")])),_:1,__:[45]})])])])]),n[57]||(n[57]=l("p",null,"共存3",-1)),n[58]||(n[58]=l("ul",null,[l("li",null,[i(" bootstrap框架也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件。 "),l("ul",null,[l("li",null,"引入 bootstrap.min.css"),l("li",null,"先引入jQuery.min.js， 再去引入 bootstrap.min.js")])]),l("li",null,[i(" 案例：发布微博案例 "),l("pre",null,[l("code",{class:"language-js line-numbers"},`  $(function() {
      $('.btn').on('click', function() {
          var li = $('<li></li>');
          li.html($('.text').val() + "<a> href='javascript:;'>删除</a>");
          if ($('.text').val() != '') {          // 判断如果内容为空则发布不了
              $('ul').prepend(li);
              li.slideDown();                    // 先影藏，再有滑动效果
              $('.text').val('');
          } else {
              return false;
          }
      })
      //这里需要使用 on（）进行事件绑定，可以给未来元素绑定
      $('ul').on('click', 'a', function() {
          $(this).parent().slideUp(function() {  // slideUp他们里面都有回调函数
              $(this).remove();                  // 上面一层已经是li了，所以这里的this就是li
          });
      })
  })`)])])],-1))]),_:1,__:[53,54,55,56,57,58]}),u(t,{id:"part27",shadow:"hover"},{default:e(()=>n[59]||(n[59]=[l("h2",null,"toDoList 分析",-1),l("p",null,"前言",-1),l("ul",null,[l("li",null,"刷新页面不会丢失数据，因此需要用到本地存储localStorage"),l("li",null," 核心思路：不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据 "),l("li",null,"存储的数据格式：var toDoList=[{title:‘xxx'，done:false}]"),l("li",null," 注意点1：本地存储 localStorage里面只能存储字符串格式，因此需要把对象转换为字符串JSON.stringify（）。 "),l("li",null," 注意点2：获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse（）我们才能使用里面的数据。 "),l("li",null,"利用事件对象.keyCode判断用户按下回车键（13）。"),l("li",null,"声明一个数组，保存数据"),l("li",null," 先要读取本地存储原来的数据（声明函数getData()），放到这个数组里面。 "),l("li",null,"之后把最新从表单获取过来的数据，追加到数组里面。"),l("li",null,"最后把数组存储给本地存储（声明函数savaDate()）"),l("li",null,"点击里面的a链接，不是删除的i，而是删除本地存储对应的数据。"),l("li",null," 核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li "),l("li",null,"我们可以给链接自定义属性记录当前的索引号"),l("li",null," 根据这个索引号删除相关的数据----数组的splice（i，1）方法 ，第一个参数是从哪个位置开始删除，第二个参数是删除几个 "),l("li",null,"存储修改后的数据，然后存储给本地存储"),l("li",null,"重新渲染加载数据列表"),l("li",null,"因为a是动态创建的，我们使用on方法绑定事件"),l("li",null," 当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。 "),l("li",null,"点击之后，获取本地存储数据。"),l("li",null,"修改对应数据属性done为当前复选框的checked状态。"),l("li",null,"之后保存数据到本地存储"),l("li",null,"重新渲染加载数据列表"),l("li",null," load加载函数里面，新增一个条件，如果当前数据的done为true就是已经完成的，就把列表渲染加载到ul里面 "),l("li",null," 如果当前数据的done为false，则是待办事项，就把列表渲染加载到ol里面 ")],-1),l("pre",null,[l("code",{class:"language-html line-numbers"},`  <!-- html -->
  <body>
    <!-- html 头部部分 -->
    <header>
        <section>
            <label for="title">ToDoList</label>
            <input type="text" id="title" name="title" placeholder="add toDo" required="required">
        </section>
    </header>
    <!-- 主体部分 -->
    <section>
        <h2>正在做的事情<span id="todocount">0</span></h2>
        <ol id="todolist" class="demo-box"></ol>
        <h2>已完成<span id="donecount">0</span></h2>
        <ul id="donelist"></ul>
    </section>
    <!-- 尾部 -->
    <footer>
        Copyright © 2021 toDoList
    </footer>
  </body>

  // css
  <style>
  body {margin: 0;padding: 0;font-size: 16px;background-color: #dfdfdf;}
  header {height: 50px;background: #535353;}
  header section {margin: 0 auto;}
  header section label {float: left;width: 100px;line-height: 50px;color: #fff;font-size: 24px;cursor: pointer;
    font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;}
  header section input {float: right; width: 60%;height: 24px; margin-top: 12px; text-indent: 10px;border-radius: 5px;
    box-shadow: 0 1px 0, 0 1px 6px rgba(0, 0, 0, 0.45) inset;border: none;
  }
  header section input:focus {outline-width: 0;}
  section {margin: 0 auto;}
  section h2 {position: relative;}
  section h2 span { position: absolute;top: 2px;right: 5px;display: inline-block; padding: 0 5px;width: 10px;
  height: 20px;border-radius: 20px;background: #fff;line-height: 22px; text-align: center;color: chartreuse;font-size: 14px;
  }
  section ol,
  section ul {padding: 0;list-style: none;}
  section ol li,
  section ul li {background-color: #fff;}
  section ol li input,
  section ul li input {position: absolute;top: 2px;left: 10px;width: 22px;height: 22px;cursor: pointer;}
  section ol li p,
  section ul li p {margin: 0;}
  section ol li p input,
  section ul li p input {top: 3px;left: 40px;width: 70%;height: 20px;line-height: 14px;text-indent: 5px;font-size: 14px;
  }
  section ol li,
  section ul li {height: 32px;line-height: 32px;position: relative;margin-bottom: 10px;padding: 0 45px;border-left: 5px solid #629A9C;box-shadow: 0 1px 2px #4e4e4e;
  }
  section ol li a,
  section ul li a { position: absolute;top: 2px;right: 5px; display: inline-block;width: 14px;height: 12px;border-radius: 14px;
    border: 6px double #fff;background: #ccc;line-height: 14px;text-align: center;color: #fff; font-weight: bold;
    font-size: 14px;cursor: pointer;
  }
  section ol li {cursor: move;}
  section ul li {border-left: 5px solid #999;opacity: 0.5;}
  footer {color: #666;font-size: 14px;text-align: center;}
  footer a { color: #666;text-decoration: none;color: #999;}
  @media screen and (max-device-width: 620px) ｛section {width: 96%;padding: 0 2%;}｝
  @media screen and (min-width: 621px) ｛section { width: 600px;padding: 0 10px;}｝
  </style>

  <script>
  $(function() {
    // 存储的数据格式：var toDoList=[{title:‘xxx'，done:false}]
    //4.5 每次刷新页面或者打开页面都要加载本地存储的数据，所以提前调用一次
    load();
    $('#title').on('keydown', function(event) { // 1、判断用户按了哪个键，用事件对象
        if (event.keyCode === 13) { // 1.1、判断用户如果按了回车键，就执行下面代码
            // 10、判断表单中的值不为空时才执行
            if ($(this).val() !== '') {
                // 1.2先读取本地原来的存储数据，因为要经常用，所以使用调用函数
                // 1.7,声明一个数组，保存数据
                var local = getDate();
                // console.log(local);
                // 2、把 localStorage 里的数据更新，把最新的数据追加给local数组,表单输入的值
                local.push({ title: $(this).val(), done: false });
                // 3.1调用保存函数
                saveDate(local);
                // 4.1 把本地存储数据渲染到页面，声明函数调用
                load();
                // 9、当输入完，input里面的值要清空
                $(this).val('');
            } else {
                alert('请输入内容');
            }
        }
    });
    //6、删除操作
    $('ol,ul').on('click', 'a', function() {
        // 6.1 先获取本地存储
        var data = getDate();
        // console.log(data);
        // 6.2修改数据
        var index = $(this).attr('id'); // 获取每个自定义id属性的索引号
        data.splice(index, 1);
        // console.log(index);
        // 6.3保存本地存储
        saveDate(data);
        // 6.4 重新渲染页面
        load();
    });
    // 7 正在进行或者已完成进行操作
    $('ol,ul').on('click', 'input', function() {
        // 7.1 先获取本地存储
        var data = getDate(); //局部变量不会影响
        // console.log(data);
        // 7.2修改数据
        var index = $(this).siblings('a').attr('id'); // 获取每个自定义id属性的索引号
        data[index].done = $(this).prop('checked');
        // 7.3保存本地存储
        saveDate(data);
        // 7.4 重新渲染页面
        load();
    })

    // 1.3获取本地存储数据的函数
    function getDate() {
        var data = localStorage.getItem('todolist');
        // 1.4 添加判断条件，如果表单不为空，才去存储
        if (data !== null) {
            return JSON.parse(data); // 1.5 返回转换为对象格式的数据，因为本地存储只能存储字符串格式数据
        } else {
            return []; // 1.6 否则返回一个空数据 对象
        }
    };
    // 3、保存本地存储数据,并添加形参，等待调用
    function saveDate(data) {
        localStorage.setItem('todolist', JSON.stringify(data)); //3.2存储只能是字符串，所以要转换下
    };
    //4 渲染加载数据
    function load() {
        // 8 在渲染的时候，声明两个变量存储已完成和待办的数量，当添加到已完成的时候 ++，当添加到待办的时候也++
        var todoCount = 0;
        var doneCount = 0;
        //4.2先读取本地存储数据
        var date = getDate();
        // console.log(date);
        // 5、在遍历之前先要清空ol和 ul里面的数据，要不然会重复加载
        $('ol,ul').empty();
        //4.3遍历存储数据  回调函数中两个数据，第一个是索引号（属性），第二个参数是属性值,参数名自己定义，什么都行
        $.each(date, function(i, ele) {
                // console.log(ele);
                // 8，添加判断条件，当完成的要放在ul里面，未完成的要放在ol里面,条件看 done 里的是true还是false
                if (ele.done) { //属性值是true还是false
                    //4.4 有几个数据就生成几个li,li里面手动添加标签，也就是在遍历的时候，生成相应的数据
                    $('ul').prepend('<li><input type="checkbox" checked="checked"><p>' + ele.title + '</p><a href="javascript:;" id=' + i + '></a></a></li>');
                    doneCount++;
                } else {
                    $('ol').prepend('<li><input type="checkbox"><p>' + ele.title + '</p><a href="javascript:;" id=' + i + '></a></a></li>');
                    todoCount++;
                }
            })
            // 8.1当判断完成后，值添加到文本里
        $('#todocount').text(todoCount);
        $('#donecount').text(doneCount);
    };
  })
  <\/script>`)],-1)])),_:1,__:[59]}),u(t,{id:"part28",shadow:"hover"},{default:e(()=>n[60]||(n[60]=[l("h2",null,"移动端的轮播图",-1),l("p",null,"代码",-1),l("pre",null,[l("code",{class:"language-js line-numbers"},`  <!-- rotation chart -->
  <div class="wrap">
      <ul id="navs" class="navs">
          <li><a> href="javascript:;"><img data-lazy-src="./images/upload/chart_img3.png" alt=""></a></li>
          <li><a> href="javascript:;"><img data-lazy-src="./images/upload/chart_img1.png" alt=""></a></li>
          <li><a> href="javascript:;"><img data-lazy-src="./images/upload/chart_img2.png" alt=""></a></li>
          <li><a> href="javascript:;"><img data-lazy-src="./images/upload/chart_img3.png" alt=""></a></li>
          <li><a> href="javascript:;"><img data-lazy-src="./images/upload/chart_img1.png" alt=""></a></li>
      </ul>
      <!-- 圆点 -->
      <ul id="bots">
          <li> class="bot active"></li>
          <li> class="bot"></li>
          <li> class="bot"></li>
      </ul>
  </div>`)],-1)])),_:1,__:[60]})]),_:1},8,["data"])}}});export{C as default};
