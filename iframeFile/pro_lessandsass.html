<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="author" content="XIONGBAB"/><meta name="description" content="MyLifeMemory"/><meta name="keywords" content="XIONGBAB,MyLifeMemory,"/><meta http-equiv="Pragma" content="no-cache"/><meta http-equiv="Window-target" content="_top"/><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1user-scalable=no"/><link id="icon-link" rel="Shortcut Icon" href=""/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-okaidia.min.css"/><title>pro_lessandsass</title><script defer="defer" src="../static/js/runtime~iframeJs.38887298.js"></script><script defer="defer" src="../static/js/489.0788b82d.js"></script><script defer="defer" src="../static/js/iframeJs.f167e449.js"></script><link href="../static/css/iframeJs.98885fb8.css" rel="stylesheet"></head><body><div class="container"><div class="centerBox"><div class="tipContent"><span class="tipBtn">重要提示</span><div class="tipText"><em>1、在任何开发下（代码 /单词 / 正规写法，都不能写错，写错了检查起来会头痛）</em> <em>2、颜色分类：文本 <i>黑色</i> 、重点 <i>红色</i> 、注释 <i>绿色</i> 、特殊 <i>棕色</i> 、首行缩进两个字符、链接默认蓝色 </em><em>3、字符默认大小16px，重点20px，标题24px，特殊28px，最小为14px</em></div></div><div class="tagContent"><span class="tipBtn">文本内容</span><h3>一、Sass安装</h3><ul><li>方法一：官网 <a href="sass-lang.com">sass-lang.com</a> ， 中文文档 <a href="https://www.sass.hk/docs/">https://www.sass.hk/docs/</a></li><li>方法二（推荐）：Vscode 安装插件 easysass 在配置里settings.json中配置，默认会输出两个文件，一个压缩和一个未压缩， 文件命名为 index.scss<ol><li>配置路径，到settings设置</li><li>如果不是在根目录下的sass文件夹，那么就可能不会输出.css文件，需要用监视<ul class="noList"><li><table><tr><th>说明</th><th>描述</th></tr><tr><td>全局安装 sass</td><td>npm install -g sass</td></tr><tr><td>将sass文件转换为css文件</td><td>sass --watch test.scss output.css 执行上面语句会监听scss文件变化，一旦文件变化并保存后将立即输出到css文件上</td></tr><tr><td>监听目录的变化</td><td>sass --watch app/sass:public/stylesheets<br/>sass将会监听src/sass目录下所有文件的变动，并编译css到public/stylesheets目录。<br/>其中以冒号进行分割，前面是sass目录，后面是css目录。</td></tr></table></li></ul></li></ol></li></ul><h3>二、VSCode插件（Easy Sass）</h3><ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Javascript</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-javascript">  /* 配置 */
  "easysass.formats": [    
    {
      "format": "expanded",          /* 格式为 扩展*/ 
      "extension": ".css"            /* 扩展名为.css */
    },
    {
      "format": "compressed",        /* 格式为 压缩*/ 
      "extension": ".min.css"        /* 扩展名为.min.css */
    }
  ],
  "easysass.targetDir": "./css/",    /* 自定义输出位置 ,这样写的话你在创建Sass文件夹后，输出会到css文件夹下*/ </code></pre></div></li></ul><h3>三、语法：四种格式</h3><ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  /* nested嵌套： */
  div {
    width: 10px; }
    div ul {
      width: 20px; }
      div ul li {
        width: 30px; }
  
  /* compact紧凑： */
  div { width: 10px; }
  div ul { width: 20px; }
  div ul li { width: 30px; }

  /* expanded扩展： */
  div {width: 10px;}
  div ul {width: 20px;}
  
  div ul li {width: 30px;}
  
  /* compressed压缩：  */
  div{width:10px}
  div ul{width:20px}
  div ul li{width:30px}</code></pre></div></li></ul><h3>四、sass和scss 两种语法区别</h3><ul><li>原始缩进式： .sass<ol><li>/* 多行注释 sass写法</li><li>// 单行写法<br/>&nbsp;&nbsp;&nbsp;其他内容sass只需要缩进下就可以达到注释效果</li><li><pre><code class="language-css">  @import base
  =alert
      color:#333
  .alert-warning
      +alert
  ul
      font-size: 15px
      li
          list-style:non</code></pre></li></ol></li><li>sassy css: .scss<pre><code class="language-css">  /* 多行写法
     多行要写尾部
  */
  
  // 单行 且 每行都要加反斜杠

  @import "base";
  @mixin alert {color: #333;}
  .alert-warning {@include alert;}
  ul {
      font-size: 15px;
      li {
          list-style: none;
      }
  }</code></pre></li></ul><h3>五、语法</h3><ul><li>变量<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  $color-red: #333;
  $border: 1px solid $color-red;
  div{color:$color-red;}
  h1{border:$border;}   /* 可以变量中引用变量 */ </code></pre></div></li></ul></li><li>嵌套<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  div {
      color:$color-red;
      h1 {border: $border;}
      &:hover { color: #333;}
      & &-text{ color: #444;}
  }
  
  /* 可以使用根来嵌套 */
  body{font-size: 12px;font-weight: 600;font-family: 'Courier New', Courier, monospace;}

  /* 使用嵌套简写 */
  body{
      font: {   /* 注意font: 加上空格 再写{} */
          size: 12px;weight: 600;family: 'Courier New', Courier, monospace;
      }
  }</code></pre></div></li></ul></li><li>混合<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  @mixin alert {                               /* 定义mixin */
      color: #444;
      background-color: #666;
      a {color: #666;}                         /* 可以使用嵌套 */
      
  }
  
  .alert-warning {                             /* 类使用mixin */
      @include alert;                          /* 使用关键字  @include */
  }

  /* 高级用法 */
  @mixin alert($color-red, $border) {          /* 定义mixin  （）里添加变量参数 */
      color: $color-red;background-color: $border;
      a {color: darken($color-red, 10%); }     /* 可以使用嵌套,darken是颜色加深的函数，后面是加深值 */
  }
  
  .alert-warning {                             /* 类使用mixin */
      @include alert(#666,#777);               /* 使用关键字  @include，可以不传参，也可以传入实参 */
  } 
  .alert-info {                                /* 类使用mixin */
      @include alert($color-red:#fff,$border:#ccc); /* 可以定义变量初始值 */
  }
  
  /* 注意：混合形参可以给默认值，或者给null ,除掉某些样式，不会生成到最终的CSS样式中，除非我们调用混合宏时为其赋值。*/
  
  /* sass mixin variable fun start */
  @mixin displayStyle($display: null, $justifyContent: null, $alignItems: null) {
      display: $display;justify-content: $justifyContent;align-items: $alignItems;
  }
  @mixin widthStyle($width: null, $height: null, $color: null) {
      width: $width;height: $height;color: $color;
  }
  @mixin fontStyle($fontSize: null, $color: null, $fontWeight: null) {
      font-size: $fontSize;color: $color;font-weight: $fontWeight;
  }
  @mixin positionStyle($position: null, $top: null, $left: null) {
      position: $position;top: $top;left: $left;
  }
  @mixin borderStyle($size: null, $style, $color) {
      border: $size $style $color;
  }
  @mixin borderRadius($top: null, $right: null, $bottom: null, $left: null) {
      border-radius: $top $right $bottom $left;
  }
  @mixin imgStyle($address: null, $style: null, $width: null, $height: null) {
      $url: url; background: #{$url }($address) $style;background-size: $width $height;
  }
  @mixin spacingStyle($margin: null, $padding: null) {
      margin: $margin;padding: $padding;
  }
  @mixin pseudoClass($width: null, $height: null) {
      content: "";display: block;width: $width;height: $height;}

  /* sass mixin variable fun ebd */
  /* 当不确定形参个数时，可用...代替 @mixin box-shadow($shadows...) */
  @mixin box-shadow($shadows...) {
    -moz-box-shadow: $shadows;
    -webkit-box-shadow: $shadows;
    box-shadow: $shadows;
  }
  .shadows {
    @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
  }</code></pre></div></li></ul></li><li>继承exteng<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  .alert{padding: 15px;}
  .alert a{font-weight: bold;}
  .alert-info{   /* 继承 */
      @extend .alert;    /* 关键字  extend */
      background-color: #ccc;
  }
  
  /* 输出css结果为 */
  .alert, .alert-info{padding: 15px;}
  .alert a, .alert-info a{font-weight: bold;}
  .alert-info{background-color: #ccc;}</code></pre></div></li></ul></li><li>导入import， 导入partials文件<ol><li>sass/_base.css</li><li>sass/style.scss</li><li>partials文件要以下划线命名开头 _base.scss，这种文件不会被编译，而是等待@import导入</li><li>在@import 导入 _base.scss ， @import “base”; 不需要加后缀，会自动解析</li></ol></li><li>注释<ol><li>/* 我写一个多行注释<br/>* 这种会生成在css文件里面 */</li><li>/*! 强制输出的注释内容，压缩的css中也会出现,就是在前面加个！号*/</li><li>// 单行注释不会出现在Css文件里面</li></ol></li><li>查看类型 type-of()</li><li>运算加括号（1 x 2）</li><li>函数：数学<ul class="noList"><li><table><tr><th>函数</th><th>描述</th><th>函数</th><th>描述</th></tr><tr><td>abs(10px)</td><td>处理数字函数取绝对值</td><td>round(3.5)</td><td>保留整数</td></tr><tr><td>ceil(3)</td><td>保留整数 进位，输出4，不会四舍五入</td><td>floor(3.6)</td><td>保留整数，向下取整</td></tr><tr><td>percentage(650px / 1000px)</td><td>百分比 65%</td><td>min(1,2,3)</td><td>取最小值 1</td></tr><tr><td>max(1,2,3)</td><td>取最大值 3</td><td></td><td></td></tr></table></li></ul></li><li>函数：字符串<ul class="noList"><li><table><tr><th>函数</th><th>描述</th><th>函数</th><th>描述</th></tr><tr><td>to-upper-case(变量)</td><td>全部转大写</td><td>to-lower-case(变量)</td><td>全部转小写</td></tr><tr><td>str-length(变量)</td><td>获取字符长度</td><td>str-index(检查字符串，判断位置)</td><td>获取位置</td></tr><tr><td>str-insert(变量，“插入值”，位置)</td><td>插入</td><td></td><td></td></tr></table></li></ul></li><li>函数：color<ul class="noList"><li><table><tr><th>函数</th><th>描述</th><th>函数</th><th>描述</th></tr><tr><td>rgb()</td><td>红，绿，蓝数量来改变颜色</td><td>rgba()</td><td>红，绿，蓝数量，alpha通道0-1 来改变颜色</td></tr><tr><td>hsl()</td><td>色相0，饱和度%，明度% ，会转换成rgb()</td><td>hsla()</td><td>色相0，饱和度%，明度%，alpha通道0-1，会转换成rgba()</td></tr><tr><td>adjust-hue()</td><td>颜色，度数deg，调整颜色，会转换成十六进制颜色，相当ps中颜色的滑块</td><td>lighten()</td><td>处理的颜色，增加的明度%，调整颜色</td></tr><tr><td>dorken()</td><td>颜色，减少明度%，调整颜色</td><td>saturate()</td><td>颜色，增加饱和度%， 改变纯度</td></tr><tr><td>desaturate()</td><td>颜色，减少饱和度% ， 改变纯度</td><td>transparent()</td><td>颜色，减少的透明度0-1，转换成rgba</td></tr><tr><td>opacify()</td><td>颜色，0-1增加颜色的不透明度,转换成rgba</td><td></td><td></td></tr></table></li></ul></li><li>列表函数：list 列表函数，可用（）或者，分割<ul class="noList"><li><table><tr><th>函数</th><th>描述</th><th>函数</th><th>描述</th></tr><tr><td>length()</td><td>列表，获取长度，里面的位置是index索引值</td><td>nth()</td><td>列表，获取第几个项</td></tr><tr><td>index()</td><td>列表，指定值，输出指定值的位置</td><td>append()</td><td>列表，插入值，增加</td></tr><tr><td>join()</td><td>列表，列表，组合</td><td>map</td><td>map名/变量：(键：值，键：值)</td></tr><tr><td>map-get()</td><td>map名,键 ， 返回键的值</td><td>map-key()</td><td>map名，返回列表里所有的键</td></tr><tr><td>map-valuese()</td><td>map名，返回列表里所有的值</td><td>map-has-key()</td><td>map名，值。判断map里面有没有这个值，返回布尔值</td></tr><tr><td>map-remove()</td><td>map名，键，键 ，移除多个用逗号分隔</td><td></td><td></td></tr></table></li></ul></li><li>布尔值 true / false<br/>ont</li><li>interpolation 类似模版字符串<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  $version: "0.0.1";
  /* 项目当前的版本是： #{$version} */
  
  $name: "info";
  $attr: "border";
  
  .alert-#{$name} {#{$attr}-color: #ccc;}
  
  输出结果：
  /* 项目当前的版本是： 0.0.1 
  .alert-info { 
      border-color: #ccc; 
  } */ </code></pre></div></li></ul></li><li>@echo 循环输出<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  /* @each $var in $list{} */
  $icons: a b c;
  @each $icon in $icons {.icon-#{$icon} {background-image: url(../img/icons/#{$icon}.svg);}}
  $list: (1: hb_img52,2: hb_img51,3: hb_img53);
  @each $key, $var in $list {
      .rotationImg:nth-child(#{$key}) {
          @include imgStyle("../images/upload/#{$var}.jpg", no-repeat, 100%, 100%);}</code></pre></div></li></ul></li><li>@while 循环输出,条件为真一直输出，条件为假则中断<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  $condition: 6;
  @while $condition>0 {
      .item-#{$condition} {width: 5px * $condition;}
      $condition: $condition - 2;  
  }
  /* 输出结果
      .item-6 {width: 30px;}
      .item-4 {width: 20px;}
      .item-2 { width: 10px;} */</code></pre></div></li></ul></li><li>@if 判断:变量值是真是假 { 然后才输出这里的代码} else if {} else{}<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  @if $use-prefixes: true;    /* true会输出  false不会输出  */
  .rounded {
      @if $use-prefixes {
          -webkit-border-radius: 5px;
          -moz-border-radius: 8px;
          -ms-border-radius: 8px;
          -o-border-radius: 8px;
      }
      border-radius: 8px;
  }

  /* 多条件判断 */
  $theme: dark;  /* 输出black */
  body {
      @if $theme == dark {
          background-color: black;
      } @else if $theme == light {
          background-color: white;
      } @else {
          background-color: pink;
      }
  } </code></pre></div></li></ul></li><li>@if 判断:变量值是真是假 { 然后才输出这里的代码} else if {} else{}<ol><li>@for $var from &lt;开始值&gt; through &lt;结束值&gt; 包含结束值</li><li>@for $var from &lt;开始值&gt; to &lt;结束值&gt; 不包含结束值</li></ol><ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  $columns: 4;
  @for $i from 1 through $columns {
    .col-#{$i}-#{$columns} {
      width: (100% / $columns) * $i;
    }
  } </code></pre></div></li></ul></li><li>自定义函数<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  $colors: (light:#fff, dark:#000);
  @function color($key) {@return map-get($colors, $key);}

  body {background-color: color(light); }  /* 输出为#fff */ </code></pre></div></li></ul></li><li>显示错误/正确 提示<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  $colors: (light:#fff, dark:#000);
  @function color($key) {
      @if not map-has-key($colors, $key) {
          @error "在输出下会有错误提示，提示#{$key}不存在";
      }
      @return map-get($colors, $key);
  }
  
  body {background-color: color(red); } /* 给错的值 */ </code></pre></div></li></ul></li></ul><br/><br/><h3>一、Less语法</h3><ul><li>Less 变量 (Variable)<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  @width: 10px;
  @height: @width + 10px;
  
  #header {width: @width;height: @height;}</code></pre></div></li></ul></li><li>混合（Mixins）<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  /* 混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。假设我们定义了一个类（class）如下： */
  .bordered {border-top: dotted 1px black;border-bottom: solid 2px black;}
  #menu a {color: #111;.bordered(); } /* 混合写法，会调用.bordered（）的样式 */
  .post a { color: red;.bordered();}</code></pre></div></li></ul></li><li>嵌套（Nesting）<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  #header {color: black;
      .navigation {font-size: 12px;} .logo {width: 300px;}
  } 
  /* 你还可以使用此方法将伪选择器（pseudo-selectors）与混合（mixins）一同使用。
     下面是一个经典的 clearfix 技巧，重写为一个混合（mixin） (& 表示当前选择器的父级）：  */ 
  .clearfix {display: block;zoom: 1;
      &:after {content: " ";display: block;font-size: 0;height: 0;clear: both; visibility: hidden;}
  } </code></pre></div></li></ul></li><li>@规则嵌套（Nesting）和冒泡（bubbling）<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  /* @ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。
  @ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡（bubbling）。 */
  .component {
      width: 300px;
      @media (min-width: 768px) {width: 600px;@media (min-resolution: 192dpi) {background-image: url(/img/retina2x.png);}}
      @media (min-width: 1280px) {width: 800px;}
  } 
  /* 编译为： */ 
  .component { width: 300px;}
  @media (min-width: 768px) {.component {width: 600px;}}
  @media (min-width: 768px) and (min-resolution: 192dpi) {.component {background-image: url(/img/retina2x.png);}}
  @media (min-width: 1280px) {.component {width: 800px;}} </code></pre></div></li></ul></li><li>运算（Operations）<ol><li>算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。</li><li>如果可能的话，算术运算符在加、减或比较之前会进行单位换算。</li><li>计算的结果以最左侧操作数的单位类型为准。</li><li>如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换。</li></ol><ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  /* 所有操作数被转换成相同的单位 */
  @conversion-1: 5cm + 10mm; /* 结果是 6cm */
  @conversion-2: 2 - 3cm - 5mm; /* 结果是 -1.5cm   2-3=-1cm   -1cm - 5mm = -1.5cm */
  
  /* conversion is impossible */
  @incompatible-units: 2 + 5px - 3cm; // 结果是 4px */
  
  /* example with variables */
  @base: 5%;
  @filler: @base * 2; /* 结果是 10% */
  @other: @base + @filler; /* 结果是 15% */ 
  
  /* 为了与 CSS 保持兼容，calc() 并不对数学表达式进行计算，但是在嵌套函数中会计算变量和数学公式的值。  */
  @var: 50vh/2;
  width: calc(50% + (@var - 20px)); // 结果是 calc(50% + (25vh - 20px)) </code></pre></div></li></ul></li><li>转义（Escaping）<ol><li>转义（Escaping）允许你使用任意字符串作为属性或变量值。</li><li>任何 ~"anything" 或 ~'anything' 形式的内容都将按原样输出，除非 interpolation</li></ol><ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  @min768: ~"(min-width: 768px)";
  .element {@media @min768 {font-size: 1.2rem;}} 
  
  /* 编译为： */
  @media (min-width: 768px) {.element {font-size: 1.2rem;}} 
  
  /* 注意，从 Less 3.5 开始，可以简写为： */
  @min768: (min-width: 768px);
  
  .element {@media @min768 {font-size: 1.2rem;}} </code></pre></div></li></ul></li><li>函数（Function）<ol><li>Less 内置了多种函数用于转换颜色、处理字符串、算术运算等。</li><li>这些函数在Less 函数手册中有详细介绍。</li><li>函数的用法非常简单。下面这个例子将介绍如何利用 percentage 函数将 0.5 转换为 50%，</li><li>将颜色饱和度增加 5%，以及颜色亮度降低 25% 并且色相值增加 8 等用法：</li></ol><ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  @base: #f04615;
  @width: 0.5;
  
  .class {
      width: percentage(@width);   /* returns `50%`  */
      color: saturate(@base, 5%);
      background-color: spin(lighten(@base, 25%), 8);
  } </code></pre></div></li></ul></li><li>命名空间和访问符<ol><li>有时，出于组织结构或仅仅是为了提供一些封装的目的，</li><li>你希望对混合（mixins）进行分组。你可以用 Less 更直观地实现这一需求。</li><li>假设你希望将一些混合（mixins）和变量置于 #bundle 之下，为了以后方便重用或分发：</li></ol><ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  #bundle() {
      .button {display: block;border: 1px solid black;background-color: grey;
          &:hover {background-color: white;}
      }
      .tab {...}
      .citation {...}
  }
  /* 现在，如果我们希望把 .button 类混合到 #header a 中，我们可以这样做：  */
  #header a {color: orange;#bundle.button(); } /* 还可以书写为 #bundle > .button 形式 */ </code></pre></div></li></ul></li><li>映射（Maps）<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  /* 从 Less 3.5 版本开始，你还可以将混合（mixins）和规则集（rulesets）作为一组值的映射（map）使用。 */
  #colors() {
  primary: blue;   /* .button  映射到这行 */
  secondary: green;
  }
  
  .button {
      color: #colors[primary];
      border: 1px solid #colors[secondary];
  }</code></pre></div></li></ul></li><li>作用域（Scope）<ul class="noList"><li class="codeListContainer"><div class="preBox"><span class="preSpan">Css</span> <button class="preButton">Copy&nbsp;code</button><pre><code class="language-css">  /* Less 中的作用域与 CSS 中的作用域非常类似。首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承。 */
  @var: red;
  #page {@var: white; #header {color: @var; }}  /* white  */
  
  /* 与 CSS 自定义属性一样，混合（mixin）和变量的定义不必在引用之前事先定义。因此，下面的 Less 代码示例和上面的代码示例是相同的： */
  @var: red;
  #page {#header {color: @var;} @var: white;}   /* white */</code></pre></div></li></ul></li><li>注释（Comments）<pre><code class="language-css">  /* 一个块注释 
   * style comment! */
  @var: red;
  
  // 这一行被注释掉了！
  @var: white;</code></pre></li><li>导入（Importing）<ol><li>“导入”的工作方式和你预期的一样。你可以导入一个 .less 文件，此文件中的所有变量就可以全部使用了。</li><li>如果导入的文件是 .less 扩展名，则可以将扩展名省略掉：</li></ol><pre><code class="language-css">  @import "library"; // library.less
  @import "typo.css";</code></pre></li><li>改变存储路径<pre><code class="language-js">  "less.compile": {
    "out": "../css/" /* 设置导出css路径 */
  },</code></pre></li></ul></div></div><div class="footerBox"></div></div><div id="goTop"></div></body><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.27.0/prism.min.js"></script><script>document.addEventListener("DOMContentLoaded", function (event) {
            Prism.highlightAll();
        });</script></html>